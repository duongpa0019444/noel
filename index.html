<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Magic Christmas - Final Clean</title>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1a2e 50%, #16213e 100%);
            font-family: 'Segoe UI', 'Roboto', sans-serif;
        }

        #canvas-container {
            width: 100%;
            height: 100vh;
            display: block;
        }

        /* UI Layer */
        #ui-layer {
            position: absolute;
            bottom: 40px;
            width: 100%;
            text-align: center;
            pointer-events: none;
            z-index: 100;
        }

        /* Guide text */
        .guide {
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 50px;
            padding: 12px 30px;
            display: inline-block;
            color: rgba(255, 255, 255, 0.9);
            font-size: 14px;
            margin-bottom: 20px;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.8);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            animation: textGlow 3s ease-in-out infinite;
        }

        .guide b {
            color: #FFD700;
            font-weight: 600;
        }

        /* Animation nh·∫•p nh√°y */
        @keyframes textGlow {

            0%,
            100% {
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3), 0 0 20px rgba(255, 215, 0, 0.2);
            }

            50% {
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3), 0 0 30px rgba(255, 215, 0, 0.4);
            }
        }

        button {
            pointer-events: auto;
            cursor: pointer;
            background: linear-gradient(135deg, #D32F2F 0%, #B71C1C 100%);
            color: #FFF;
            border: 2px solid #FFD700;
            padding: 16px 60px;
            border-radius: 50px;
            font-weight: 700;
            font-size: 16px;
            text-transform: uppercase;
            letter-spacing: 2px;
            box-shadow: 0 10px 40px rgba(211, 47, 47, 0.4), 0 0 20px rgba(255, 215, 0, 0.3);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        button:hover::before {
            width: 300px;
            height: 300px;
        }

        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 50px rgba(211, 47, 47, 0.5), 0 0 30px rgba(255, 215, 0, 0.5);
        }

        button:active {
            transform: translateY(-1px);
        }

        /* Camera Preview */
        #camera-preview {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 140px;
            height: 105px;
            border: 2px solid rgba(255, 215, 0, 0.4);
            border-radius: 12px;
            transform: scaleX(-1);
            opacity: 0.7;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            transition: opacity 0.3s;
            opacity: 0;
        }

        #camera-preview:hover {
            opacity: 1;
        }

        /* Copyright */
        #copyright {
            position: absolute;
            bottom: 15px;
            right: 20px;
            color: rgba(255, 255, 255, 0.4);
            font-size: 11px;
            z-index: 100;
            font-family: 'Courier New', monospace;
            pointer-events: none;
            font-style: italic;
            letter-spacing: 1px;
        }

        #error-log {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            color: #ff5252;
            background: rgba(0, 0, 0, 0.9);
            z-index: 999;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }

        /* Welcome Screen */
        #welcome-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            background: linear-gradient(135deg, #1a1a2e 0%, #0f3460 50%, #16213e 100%);
            display: flex;
            /* Hidden by default, redirect to notebook */
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 0.8s ease, visibility 0.8s ease;
        }

        #welcome-screen.hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }

        .welcome-content {
            text-align: center;
            max-width: 800px;
            padding: 40px;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(20px);
            border-radius: 30px;
            border: 2px solid rgba(255, 215, 0, 0.3);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5), 0 0 40px rgba(255, 215, 0, 0.2);
            animation: welcomeFadeIn 1s ease-out;
        }

        @keyframes welcomeFadeIn {
            from {
                opacity: 0;
                transform: translateY(30px) scale(0.95);
            }

            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        .welcome-title {
            font-size: 56px;
            font-weight: 800;
            background: linear-gradient(135deg, #FFD700, #FFA500, #FF6347);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 20px;
            text-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
            animation: titleGlow 2s ease-in-out infinite;
        }

        @keyframes titleGlow {

            0%,
            100% {
                filter: drop-shadow(0 0 10px rgba(255, 215, 0, 0.6));
            }

            50% {
                filter: drop-shadow(0 0 20px rgba(255, 215, 0, 0.9));
            }
        }

        .welcome-subtitle {
            font-size: 24px;
            color: #FFD700;
            margin-bottom: 30px;
            font-weight: 600;
            letter-spacing: 2px;
        }

        .welcome-message {
            font-size: 18px;
            color: rgba(255, 255, 255, 0.9);
            line-height: 1.8;
            margin-bottom: 40px;
            font-weight: 400;
        }

        .welcome-message p {
            margin: 15px 0;
        }

        .start-button {
            background: linear-gradient(135deg, #D32F2F 0%, #B71C1C 100%);
            color: white;
            border: 3px solid #FFD700;
            padding: 20px 70px;
            font-size: 20px;
            font-weight: 700;
            border-radius: 50px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 3px;
            box-shadow: 0 15px 50px rgba(211, 47, 47, 0.5), 0 0 30px rgba(255, 215, 0, 0.4);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .start-button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        .start-button:hover::before {
            width: 400px;
            height: 400px;
        }

        .start-button:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 20px 60px rgba(211, 47, 47, 0.6), 0 0 40px rgba(255, 215, 0, 0.6);
        }

        .start-button:active {
            transform: translateY(-2px) scale(1.02);
        }

        .christmas-icons {
            font-size: 40px;
            margin-bottom: 20px;
            animation: iconsFloat 3s ease-in-out infinite;
        }

        @keyframes iconsFloat {

            0%,
            100% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(-10px);
            }
        }

        /* Book Welcome Screen */
        .book-container {
            perspective: 2000px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 40px;
        }

        .book {
            position: relative;
            width: 600px;
            height: 400px;
            transform-style: preserve-3d;
            transition: transform 0.8s;
        }

        .page {
            position: absolute;
            width: 300px;
            height: 400px;
            background: linear-gradient(to right, #f9f6f0 0%, #fff 10%, #fff 90%, #f0ebe0 100%);
            border: 2px solid #8B4513;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            transform-style: preserve-3d;
            transform-origin: left center;
            transition: transform 0.8s ease;
            padding: 40px 30px;
            box-sizing: border-box;
            overflow: hidden;
        }

        .page::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg,
                    rgba(0, 0, 0, 0.05) 0%,
                    transparent 5%,
                    transparent 95%,
                    rgba(0, 0, 0, 0.1) 100%);
            pointer-events: none;
        }

        .page-left {
            left: 0;
            background: linear-gradient(to left, #f9f6f0 0%, #fff 10%, #fff 90%, #f0ebe0 100%);
            border-right: 1px solid #d4c5a9;
        }

        .page-right {
            right: 0;
            transform-origin: right center;
        }

        .page.flipped {
            transform: rotateY(-180deg);
        }

        .page-content {
            position: relative;
            z-index: 2;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            font-family: 'Georgia', serif;
        }

        .page-title {
            font-size: 32px;
            color: #8B0000;
            margin-bottom: 20px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }

        .page-text {
            font-size: 16px;
            line-height: 1.8;
            color: #333;
            margin: 10px 0;
        }

        .page-decoration {
            font-size: 40px;
            margin: 15px 0;
        }

        .page-number {
            position: absolute;
            bottom: 20px;
            font-size: 14px;
            color: #999;
            font-style: italic;
        }

        .page-left .page-number {
            left: 30px;
        }

        .page-right .page-number {
            right: 30px;
        }

        .book-controls {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .book-button {
            background: linear-gradient(135deg, #8B4513 0%, #654321 100%);
            color: white;
            border: 2px solid #FFD700;
            padding: 15px 30px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            box-shadow: 0 5px 20px rgba(139, 69, 19, 0.4);
            transition: all 0.3s;
        }

        .book-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(139, 69, 19, 0.6);
        }

        .book-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .start-button-book {
            background: linear-gradient(135deg, #D32F2F 0%, #B71C1C 100%);
            padding: 18px 40px;
            font-size: 18px;
            animation: pulse-glow 2s infinite;
        }

        @keyframes pulse-glow {

            0%,
            100% {
                box-shadow: 0 5px 20px rgba(211, 47, 47, 0.4), 0 0 20px rgba(255, 215, 0, 0.3);
            }

            50% {
                box-shadow: 0 8px 30px rgba(211, 47, 47, 0.6), 0 0 30px rgba(255, 215, 0, 0.5);
            }
        }

        /* Letter Box - Greeting Card */
        #letter-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            width: 600px;
            max-width: 90%;
            max-height: 80vh;
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 20px;
            padding: 50px 40px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5),
                0 0 40px rgba(255, 215, 0, 0.2),
                inset 0 0 60px rgba(255, 255, 255, 0.1);
            z-index: 500;
            opacity: 0;
            transition: all 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            overflow-y: auto;
            scrollbar-width: none;
        }

        #letter-box.visible {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
        }

        .letter-header {
            text-align: center;
            margin-bottom: 30px;
            font-family: 'Georgia', serif;
        }

        .letter-title {
            font-size: 36px;
            font-weight: bold;
            background: linear-gradient(135deg, #FFD700, #FFA500, #FF6347);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
            text-shadow: 0 2px 10px rgba(255, 215, 0, 0.3);
        }

        .letter-decoration {
            font-size: 30px;
            margin: 10px 0;
        }

        .letter-content {
            font-family: 'Georgia', serif;
            font-size: 16px;
            line-height: 1.8;
            color: rgba(255, 255, 255, 0.95);
            text-align: left;
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
        }

        .letter-content p {
            margin: 20px 0;
            opacity: 0;
            animation: fadeInText 0.8s ease-out forwards;
        }

        .letter-content p:nth-child(1) {
            animation-delay: 0.2s;
        }

        .letter-content p:nth-child(2) {
            animation-delay: 0.8s;
        }

        .letter-content p:nth-child(3) {
            animation-delay: 1.4s;
        }

        .letter-content p:nth-child(4) {
            animation-delay: 2.0s;
        }

        .letter-content p:nth-child(5) {
            animation-delay: 2.6s;
        }

        .letter-content p:nth-child(6) {
            animation-delay: 3.2s;
        }

        @keyframes fadeInText {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .letter-signature {
            text-align: right;
            margin-top: 40px;
            font-style: italic;
            color: rgba(255, 255, 255, 0.9);
            font-size: 18px;
            font-weight: 600;
            opacity: 0;
            animation: fadeInText 0.8s ease-out 3.8s forwards;
        }

        .letter-close-hint {
            text-align: center;
            margin-top: 30px;
            font-size: 14px;
            color: rgba(255, 255, 255, 0.6);
            font-style: italic;
            opacity: 0;
            animation: fadeInText 0.8s ease-out 4.4s forwards;
        }
    </style>
</head>

<body>
    <!-- Welcome Screen -->
    <div id="welcome-screen">
        <div class="welcome-content">
            <div class="christmas-icons">üéÑ ‚ùÑÔ∏è üéÅ</div>
            <h1 class="welcome-title">Magic Christmas</h1>
            <div class="welcome-subtitle">M√≥n Qu√† Gi√°ng Sinh ƒê·∫∑c Bi·ªát</div>
            <div class="welcome-message">
                <p>Ch√†o m·ª´ng em ƒë·∫øn v·ªõi kh√¥ng gian Gi√°ng sinh nhi·ªám m√†u.</p>
                <p>H√£y s·∫µn s√†ng ƒë·ªÉ tr·∫£i nghi·ªám ph√©p thu·∫≠t b·∫±ng ch√≠nh ƒë√¥i tay c·ªßa em nha.</p>
                <p><i>(cho ph√©p truy c·∫≠p Camera ƒë·ªÉ b·∫Øt ƒë·∫ßu nha b√©)</i></p>
            </div>
            <button class="start-button" onclick="startExperience()">B·∫Øt ƒë·∫ßu ngay</button>
        </div>
    </div>

    <!-- UI Vandiep -->
    <div id="ui-layer">
        <!-- Vandiep -->
        <div class="guide">
            &nbsp; ‚úä <b>Fist:</b> Tree &nbsp;|
            üñê <b>Open:</b> Explode &nbsp;|
            &nbsp; üëå <b>Pinch:</b> Zoom &nbsp;|
            &nbsp; ü´∂ <b>Heart:</b> Love &nbsp;|
            &nbsp; ‚òùÔ∏è <b>Point:</b> Letter
        </div>
        <button id="btnStart" onclick="startSystem()" style="display: none;">START MAGIC</button>
    </div>

    <!-- Vandiep -->
    <div id="copyright">¬© by t√πng d∆∞∆°ng üéÑ</div>

    <!-- Letter Box - Greeting Card -->
    <div id="letter-box" style="font-family: 'Dancing Script', cursive;">
        <div class="letter-header">
            <!-- <div class="letter-decoration">üéÑ ‚ú® üéÖ</div> -->
            <div class="letter-title">G·ª≠i ng∆∞·ªùi anh y√™u üíñ PTH</div>
            <div class="letter-decoration">‚ùÑÔ∏è üéÅ ‚≠ê</div>
        </div>
        <div class="letter-content" style="font-family: 'Times New Roman', Times, serif;">
            <p>Gi√°ng sinh l·∫°i v·ªÅ r·ªìi v√† tr·ªùi th√¨ c≈©ng l·∫°nh. V·ªùi th·ªùi ti·∫øt n√†y, ng∆∞·ªùi
                ƒë·∫ßu ti√™n m√¨nh nghƒ© ƒë·∫øn ch√≠nh l√† em, mu·ªën ƒë∆∞·ª£c c√πng ƒëi c√πng em nh∆∞ m√πa ƒë√¥ng nƒÉm ·∫•y.</p>
            <p>D√π hi·ªán t·∫°i ch√∫ng ta kh√¥ng c√≤n t∆∞ c√°ch l√† ng∆∞·ªùi y√™u, nh∆∞ng ƒë·ªëi v·ªõi a, em v·∫´n lu√¥n l√† m·ªôt ng∆∞·ªùi quan
                tr·ªçng, ng∆∞·ªùi anh quan t√¢m v√† mu·ªën ƒë·ªìng h√†nh c√πng em. Anh vi·∫øt nh·ªØng d√≤ng n√†y kh√¥ng ph·∫£i ƒë·ªÉ kh∆°i l·∫°i
                chuy·ªán c≈©, m√† ch·ªâ mu·ªën g·ª≠i ƒë·∫øn em m·ªôt ch√∫t h∆°i ·∫•m gi·ªØa m√πa ƒë√¥ng n√†y.</p>
            <p>Ch√∫c em m·ªôt m√πa Gi√°ng sinh th·∫≠t an y√™n, xinh ƒë·∫πp v√† tr√†n ƒë·∫ßy n·ª• c∆∞·ªùi. Mong r·∫±ng nh·ªØng ƒëi·ªÅu t·ªët ƒë·∫πp nh·∫•t
                s·∫Ω ƒë·∫øn v·ªõi em, ƒë·ªÉ m·ªói ng√†y tr√¥i qua ƒë·ªÅu l√† m·ªôt ni·ªÅm vui m·ªõi!</p>
            <div class="letter-signature">
                Y√™u em,<br>
            </div>
        </div>
    </div>

    <div id="canvas-container"></div>
    <video class="input_video" style="display:none"></video>
    <canvas id="camera-preview"></canvas>

    <script>
        // ==========================================
        // 1. RESOURCES CONFIG Vandiep
        // ==========================================
        const MUSIC_URL = "./audio3.mp3";
        let bgMusic = new Audio(MUSIC_URL);
        bgMusic.loop = true; bgMusic.volume = 1.0;

        const loader = new THREE.TextureLoader();
        // const photoFiles = ['./image1.jpeg', './image2.jpeg', './image3.jpeg', './image4.jpeg', './image5.jpeg'];
        const photoFiles = ['./image6.jpg', './image7.jpg', './image8.jpg', './image9.jpg', './image10.jpg', './image11.jpg', './image12.jpg', './image13.jpg', './image14.jpg', './image15.jpg', './image16.jpg', './image17.jpg', './image18.jpg', './image19.jpg', './image20.jpg', './image21.jpg', './image22.jpg', './image23.jpg', './image24.jpg', './image25.jpg', './image26.jpg', './image27.jpg', './image28.jpg', './image29.jpg', './image30.jpg', './image30.jpg'];
        const photoTextures = [];
        const photoAspectRatios = []; // L∆∞u t·ª∑ l·ªá c·ªßa m·ªói ·∫£nh

        // Load textures v·ªõi callback ƒë·ªÉ l·∫•y aspect ratio
        photoFiles.forEach((f, i) => {
            photoTextures[i] = loader.load(f, (texture) => {
                // L·∫•y k√≠ch th∆∞·ªõc th·ª±c c·ªßa ·∫£nh
                const img = texture.image;
                const aspectRatio = img.width / img.height;
                photoAspectRatios[i] = aspectRatio;
                console.log(`Image ${i}: ${img.width}x${img.height}, aspect ratio: ${aspectRatio}`);
            });
        });

        function createCustomTexture(type) {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            const cx = 64, cy = 64;

            if (type === 'gold_glow') {
                // V·∫Ω ng√¥i sao v√†ng 5 c√°nh
                ctx.clearRect(0, 0, 128, 128);

                ctx.save();
                ctx.translate(cx, cy);

                // V·∫Ω √°nh s√°ng ph√°t ra t·ª´ ng√¥i sao (tr·∫Øng xanh)
                const glowGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 50);
                glowGradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');     // Tr·∫Øng s√°ng
                glowGradient.addColorStop(0.3, 'rgba(176, 224, 255, 0.6)');   // Xanh tr·∫Øng
                glowGradient.addColorStop(1, 'rgba(176, 224, 255, 0)');
                ctx.fillStyle = glowGradient;
                ctx.beginPath();
                ctx.arc(0, 0, 50, 0, Math.PI * 2);
                ctx.fill();

                // V·∫Ω ng√¥i sao
                ctx.beginPath();
                const spikes = 5;
                const outerRadius = 25;
                const innerRadius = 12;

                for (let i = 0; i < spikes * 2; i++) {
                    const radius = i % 2 === 0 ? outerRadius : innerRadius;
                    const angle = (i * Math.PI) / spikes - Math.PI / 2;
                    const x = Math.cos(angle) * radius;
                    const y = Math.sin(angle) * radius;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();

                // Gradient cho ng√¥i sao (tr·∫Øng xanh)
                const starGradient = ctx.createRadialGradient(-5, -5, 0, 0, 0, outerRadius);
                starGradient.addColorStop(0, '#FFFFFF');   // Tr·∫Øng s√°ng
                starGradient.addColorStop(0.4, '#E0F7FF'); // Tr·∫Øng xanh nh·∫°t
                starGradient.addColorStop(1, '#B0E0FF');   // Xanh tr·∫Øng
                ctx.fillStyle = starGradient;
                ctx.fill();

                // Vi·ªÅn v√†ng ƒë·∫≠m
                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 1.5;
                ctx.stroke();

                ctx.restore();

            } else if (type === 'red_light') {
                // V·∫Ω b√¥ng tuy·∫øt ƒë·ªè
                ctx.clearRect(0, 0, 128, 128);

                ctx.save();
                ctx.translate(cx, cy);

                // √Ånh s√°ng ph√°t ra (tr·∫Øng xanh)
                const glowGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 45);
                glowGradient.addColorStop(0, 'rgba(255, 255, 255, 0.6)');     // Tr·∫Øng s√°ng
                glowGradient.addColorStop(0.4, 'rgba(176, 224, 255, 0.4)');   // Xanh tr·∫Øng
                glowGradient.addColorStop(1, 'rgba(176, 224, 255, 0)');
                ctx.fillStyle = glowGradient;
                ctx.beginPath();
                ctx.arc(0, 0, 45, 0, Math.PI * 2);
                ctx.fill();

                // V·∫Ω b√¥ng tuy·∫øt (6 c√°nh)
                const branches = 6;
                const branchLength = 22;

                for (let i = 0; i < branches; i++) {
                    ctx.save();
                    ctx.rotate((i * Math.PI * 2) / branches);

                    // Gradient cho c√°nh (tr·∫Øng xanh)
                    const branchGradient = ctx.createLinearGradient(0, 0, 0, branchLength);
                    branchGradient.addColorStop(0, '#FFFFFF');   // Tr·∫Øng
                    branchGradient.addColorStop(0.5, '#C0E8FF'); // Xanh tr·∫Øng nh·∫°t
                    branchGradient.addColorStop(1, '#87CEFA');   // Xanh da tr·ªùi

                    // C√°nh ch√≠nh
                    ctx.strokeStyle = branchGradient;
                    ctx.lineWidth = 3;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(0, branchLength);
                    ctx.stroke();

                    // C√°nh ph·ª•
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(0, branchLength * 0.6);
                    ctx.lineTo(-5, branchLength * 0.8);
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(0, branchLength * 0.6);
                    ctx.lineTo(5, branchLength * 0.8);
                    ctx.stroke();

                    ctx.restore();
                }

                // T√¢m b√¥ng tuy·∫øt (tr·∫Øng xanh)
                const centerGradient = ctx.createRadialGradient(-2, -2, 0, 0, 0, 6);
                centerGradient.addColorStop(0, '#FFFFFF');   // Tr·∫Øng
                centerGradient.addColorStop(0.5, '#E0F7FF'); // Tr·∫Øng xanh
                centerGradient.addColorStop(1, '#B0E0FF');   // Xanh tr·∫Øng
                ctx.fillStyle = centerGradient;
                ctx.beginPath();
                ctx.arc(0, 0, 6, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();

            } else if (type === 'gift_red') {
                // V·∫Ω h·ªôp qu√† 3D Isometric
                ctx.clearRect(0, 0, 128, 128);

                ctx.save();
                ctx.translate(cx, cy);

                // K√≠ch th∆∞·ªõc h·ªôp
                const boxW = 35;
                const boxH = 30;
                const boxD = 35;

                // === M·∫∂T TR√äN (TOP) ===
                ctx.beginPath();
                ctx.moveTo(0, -boxH);
                ctx.lineTo(boxW, -boxH + boxD / 2);
                ctx.lineTo(0, -boxH + boxD);
                ctx.lineTo(-boxW, -boxH + boxD / 2);
                ctx.closePath();

                // Gradient cho m·∫∑t tr√™n (tr·∫Øng xanh)
                const topGradient = ctx.createLinearGradient(-boxW, -boxH + boxD / 2, boxW, -boxH + boxD / 2);
                topGradient.addColorStop(0, '#E0F7FF');   // Tr·∫Øng xanh nh·∫°t
                topGradient.addColorStop(0.5, '#C0E8FF'); // Xanh tr·∫Øng
                topGradient.addColorStop(1, '#B0E0FF');   // Xanh tr·∫Øng ƒë·∫≠m
                ctx.fillStyle = topGradient;
                ctx.fill();
                ctx.strokeStyle = 'rgba(0,0,0,0.3)';
                ctx.lineWidth = 1;
                ctx.stroke();

                // === M·∫∂T TR∆Ø·ªöC (FRONT) ===
                ctx.beginPath();
                ctx.moveTo(-boxW, -boxH + boxD / 2);
                ctx.lineTo(0, -boxH + boxD);
                ctx.lineTo(0, boxD);
                ctx.lineTo(-boxW, boxD / 2);
                ctx.closePath();

                const frontGradient = ctx.createLinearGradient(0, -boxH + boxD, 0, boxD);
                frontGradient.addColorStop(0, '#B0E0FF');  // Xanh tr·∫Øng
                frontGradient.addColorStop(1, '#87CEFA');  // Xanh da tr·ªùi
                ctx.fillStyle = frontGradient;
                ctx.fill();
                ctx.strokeStyle = 'rgba(0,0,0,0.3)';
                ctx.stroke();

                // === M·∫∂T B√äN PH·∫¢I (RIGHT) ===
                ctx.beginPath();
                ctx.moveTo(boxW, -boxH + boxD / 2);
                ctx.lineTo(0, -boxH + boxD);
                ctx.lineTo(0, boxD);
                ctx.lineTo(boxW, boxD / 2);
                ctx.closePath();

                const rightGradient = ctx.createLinearGradient(0, -boxH + boxD, 0, boxD);
                rightGradient.addColorStop(0, '#A0D8F0');  // Xanh nh·∫°t
                rightGradient.addColorStop(1, '#70B8E0');  // Xanh ƒë·∫≠m h∆°n
                ctx.fillStyle = rightGradient;
                ctx.fill();
                ctx.strokeStyle = 'rgba(0,0,0,0.3)';
                ctx.stroke();

                // === RUY BƒÇNG V√ÄNG ===

                // Ruy bƒÉng m·∫∑t tr√™n
                ctx.beginPath();
                ctx.moveTo(-5, -boxH);
                ctx.lineTo(5, -boxH);
                ctx.lineTo(5, -boxH + boxD);
                ctx.lineTo(-5, -boxH + boxD);
                ctx.closePath();
                const ribbonTopGrad = ctx.createLinearGradient(-5, -boxH, 5, -boxH);
                ribbonTopGrad.addColorStop(0, '#FFFFFF');   // Tr·∫Øng
                ribbonTopGrad.addColorStop(0.5, '#F0F8FF'); // Tr·∫Øng xanh
                ribbonTopGrad.addColorStop(1, '#FFFFFF');   // Tr·∫Øng
                ctx.fillStyle = ribbonTopGrad;
                ctx.fill();

                // Ruy bƒÉng m·∫∑t tr∆∞·ªõc
                ctx.beginPath();
                ctx.moveTo(-5, -boxH + boxD);
                ctx.lineTo(5, -boxH + boxD);
                ctx.lineTo(5, boxD);
                ctx.lineTo(-5, boxD);
                ctx.closePath();
                const ribbonFrontGrad = ctx.createLinearGradient(0, -boxH + boxD, 0, boxD);
                ribbonFrontGrad.addColorStop(0, '#F0F8FF'); // Tr·∫Øng xanh
                ribbonFrontGrad.addColorStop(1, '#E0F0FF'); // Tr·∫Øng xanh nh·∫°t
                ctx.fillStyle = ribbonFrontGrad;
                ctx.fill();

                // === N∆† 3D ===
                const bowY = -boxH - 5;

                // C√°nh n∆° tr√°i
                ctx.beginPath();
                ctx.ellipse(-15, bowY, 12, 8, -Math.PI / 4, 0, Math.PI * 2);
                const bowLeftGrad = ctx.createRadialGradient(-18, bowY - 3, 0, -15, bowY, 12);
                bowLeftGrad.addColorStop(0, '#FFFFFF');   // Tr·∫Øng
                bowLeftGrad.addColorStop(0.5, '#F0F8FF'); // Tr·∫Øng xanh
                bowLeftGrad.addColorStop(1, '#E0F0FF');   // Tr·∫Øng xanh nh·∫°t
                ctx.fillStyle = bowLeftGrad;
                ctx.fill();
                ctx.strokeStyle = '#C0E0F0';  // Vi·ªÅn xanh nh·∫°t
                ctx.lineWidth = 1;
                ctx.stroke();

                // C√°nh n∆° ph·∫£i
                ctx.beginPath();
                ctx.ellipse(15, bowY, 12, 8, Math.PI / 4, 0, Math.PI * 2);
                const bowRightGrad = ctx.createRadialGradient(18, bowY - 3, 0, 15, bowY, 12);
                bowRightGrad.addColorStop(0, '#FFFFFF');   // Tr·∫Øng
                bowRightGrad.addColorStop(0.5, '#F0F8FF'); // Tr·∫Øng xanh
                bowRightGrad.addColorStop(1, '#E0F0FF');   // Tr·∫Øng xanh nh·∫°t
                ctx.fillStyle = bowRightGrad;
                ctx.fill();
                ctx.strokeStyle = '#C0E0F0';  // Vi·ªÅn xanh nh·∫°t
                ctx.lineWidth = 1;
                ctx.stroke();

                // T√¢m n∆°
                ctx.beginPath();
                ctx.arc(0, bowY, 7, 0, Math.PI * 2);
                const bowCenterGrad = ctx.createRadialGradient(-2, bowY - 2, 0, 0, bowY, 7);
                bowCenterGrad.addColorStop(0, '#FFFFFF');   // Tr·∫Øng
                bowCenterGrad.addColorStop(0.5, '#F0F8FF'); // Tr·∫Øng xanh
                bowCenterGrad.addColorStop(1, '#D0E8FF');   // Xanh nh·∫°t
                ctx.fillStyle = bowCenterGrad;
                ctx.fill();
                ctx.strokeStyle = '#B0D0E0';  // Vi·ªÅn xanh
                ctx.lineWidth = 1.5;
                ctx.stroke();

                // √Ånh s√°ng ph√°t ra t·ª´ h·ªôp qu√† (tr·∫Øng xanh)
                const glowGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 60);
                glowGradient.addColorStop(0, 'rgba(255, 255, 255, 0.2)');     // Tr·∫Øng
                glowGradient.addColorStop(0.5, 'rgba(176, 224, 255, 0.1)');   // Xanh tr·∫Øng
                glowGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                ctx.fillStyle = glowGradient;
                ctx.beginPath();
                ctx.arc(0, 0, 60, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }
            return new THREE.CanvasTexture(canvas);
        }

        const textures = {
            gold: createCustomTexture('gold_glow'),
            red: createCustomTexture('red_light'),
            gift: createCustomTexture('gift_red')
        };

        // ==========================================
        // 2. SYSTEM CONFIG Vandiep
        // ==========================================
        const CONFIG = {
            goldCount: 2000,
            redCount: 300,
            giftCount: 150,
            explodeRadius: 65,
            photoOrbitRadius: 40,
            photoCount: 25,  // S·ªë l∆∞·ª£ng ·∫£nh hi·ªÉn th·ªã (ƒë√£ tƒÉng t·ª´ 8 l√™n 25)
            treeHeight: 70,
            treeBaseRadius: 35
        };

        let scene, camera, renderer;
        let groupGold, groupRed, groupGift;
        let photoMeshes = [];
        let titleMesh, starMesh, loveMesh;
        let snowParticles, galaxyStars; // Tuy·∫øt r∆°i v√† sao thi√™n h√†

        let state = 'TREE';
        let selectedIndex = 0;
        let handX = 0.5;
        let handY = 0.5; // Track vertical hand position

        // ==========================================
        // 3. THREE.JS SYSTEM Vandiep
        // ==========================================
        function init3D() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.002);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 100;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);

            groupGold = createParticleSystem('gold', CONFIG.goldCount, 2.8);
            groupRed = createParticleSystem('red', CONFIG.redCount, 4.2);
            groupGift = createParticleSystem('gift', CONFIG.giftCount, 3.8);

            createPhotos();
            createDecorations();
            // createSnowfall(); // Tuy·∫øt r∆°i
            createGalaxyBackground(); // Thi√™n h√†
            animate();
        }

        // T·∫°o hi·ªáu ·ª©ng tuy·∫øt r∆°i 3D
        function createSnowfall() {
            const snowCount = 1000;
            const snowGeo = new THREE.BufferGeometry();
            const snowPositions = new Float32Array(snowCount * 3);
            const snowSizes = new Float32Array(snowCount);
            const snowVelocities = [];

            for (let i = 0; i < snowCount; i++) {
                // V·ªã tr√≠ ng·∫´u nhi√™n trong kh√¥ng gian
                snowPositions[i * 3] = (Math.random() - 0.5) * 200;
                snowPositions[i * 3 + 1] = Math.random() * 150 - 50;
                snowPositions[i * 3 + 2] = (Math.random() - 0.5) * 200;

                // K√≠ch th∆∞·ªõc ng·∫´u nhi√™n
                snowSizes[i] = Math.random() * 2 + 0.5;

                // V·∫≠n t·ªëc r∆°i
                snowVelocities.push({
                    y: -(Math.random() * 0.5 + 0.2),
                    drift: (Math.random() - 0.5) * 0.1
                });
            }

            snowGeo.setAttribute('position', new THREE.BufferAttribute(snowPositions, 3));
            snowGeo.setAttribute('size', new THREE.BufferAttribute(snowSizes, 1));
            snowGeo.userData.velocities = snowVelocities;

            // Texture cho tuy·∫øt
            const snowCanvas = document.createElement('canvas');
            snowCanvas.width = 32;
            snowCanvas.height = 32;
            const snowCtx = snowCanvas.getContext('2d');
            const gradient = snowCtx.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.8)');
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            snowCtx.fillStyle = gradient;
            snowCtx.fillRect(0, 0, 32, 32);
            const snowTexture = new THREE.CanvasTexture(snowCanvas);

            const snowMat = new THREE.PointsMaterial({
                size: 2,
                map: snowTexture,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                sizeAttenuation: true
            });

            snowParticles = new THREE.Points(snowGeo, snowMat);
            scene.add(snowParticles);
        }

        // T·∫°o n·ªÅn thi√™n h√† v·ªõi sao
        function createGalaxyBackground() {
            const starCount = 15000;
            const starGeo = new THREE.BufferGeometry();
            const starPositions = new Float32Array(starCount * 3);
            const starColors = new Float32Array(starCount * 3);
            const starSizes = new Float32Array(starCount);

            for (let i = 0; i < starCount; i++) {
                // Ph√¢n b·ªë sao trong kh√¥ng gian r·ªông
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(Math.random() * 2 - 1);
                const radius = 150 + Math.random() * 200;

                starPositions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                starPositions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                starPositions[i * 3 + 2] = radius * Math.cos(phi);

                // M√†u sao: tr·∫Øng, xanh nh·∫°t, v√†ng nh·∫°t
                const colorChoice = Math.random();
                if (colorChoice < 0.6) {
                    // Tr·∫Øng
                    starColors[i * 3] = 1;
                    starColors[i * 3 + 1] = 1;
                    starColors[i * 3 + 2] = 1;
                } else if (colorChoice < 0.8) {
                    // Xanh nh·∫°t
                    starColors[i * 3] = 0.8;
                    starColors[i * 3 + 1] = 0.9;
                    starColors[i * 3 + 2] = 1;
                } else {
                    // V√†ng nh·∫°t
                    starColors[i * 3] = 1;
                    starColors[i * 3 + 1] = 1;
                    starColors[i * 3 + 2] = 0.8;
                }

                // K√≠ch th∆∞·ªõc ng·∫´u nhi√™n
                starSizes[i] = Math.random() * 1.5 + 0.5;
            }

            starGeo.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
            starGeo.setAttribute('color', new THREE.BufferAttribute(starColors, 3));
            starGeo.setAttribute('size', new THREE.BufferAttribute(starSizes, 1));

            // Th√™m v·∫≠n t·ªëc r∆°i cho m·ªói sao
            const starVelocities = [];
            for (let i = 0; i < starCount; i++) {
                starVelocities.push({
                    y: -(Math.random() * 0.3 + 0.1),  // R∆°i xu·ªëng ch·∫≠m (0.1-0.4)
                    drift: (Math.random() - 0.5) * 0.05  // Tr√¥i ngang nh·∫π
                });
            }

            // T·∫°o texture b√¥ng tuy·∫øt cho sao
            const snowflakeCanvas = document.createElement('canvas');
            snowflakeCanvas.width = 64;
            snowflakeCanvas.height = 64;
            const sfCtx = snowflakeCanvas.getContext('2d');
            const center = 32;

            // V·∫Ω b√¥ng tuy·∫øt 6 c√°nh
            sfCtx.clearRect(0, 0, 64, 64);
            sfCtx.strokeStyle = '#FFFFFF';
            sfCtx.fillStyle = '#FFFFFF';
            sfCtx.lineWidth = 2;
            sfCtx.lineCap = 'round';

            // V·∫Ω 6 c√°nh ch√≠nh
            for (let i = 0; i < 6; i++) {
                sfCtx.save();
                sfCtx.translate(center, center);
                sfCtx.rotate((i * Math.PI) / 3);

                // C√°nh ch√≠nh
                sfCtx.beginPath();
                sfCtx.moveTo(0, 0);
                sfCtx.lineTo(0, -28);
                sfCtx.stroke();

                // C√°nh ph·ª• tr√°i
                sfCtx.beginPath();
                sfCtx.moveTo(0, -18);
                sfCtx.lineTo(-6, -24);
                sfCtx.stroke();

                // C√°nh ph·ª• ph·∫£i
                sfCtx.beginPath();
                sfCtx.moveTo(0, -18);
                sfCtx.lineTo(6, -24);
                sfCtx.stroke();

                sfCtx.restore();
            }

            // T√¢m b√¥ng tuy·∫øt
            sfCtx.beginPath();
            sfCtx.arc(center, center, 3, 0, Math.PI * 2);
            sfCtx.fill();

            const snowflakeTexture = new THREE.CanvasTexture(snowflakeCanvas);

            const starMat = new THREE.PointsMaterial({
                size: 1.5,
                map: snowflakeTexture,  // Th√™m texture b√¥ng tuy·∫øt
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                sizeAttenuation: true
            });

            galaxyStars = new THREE.Points(starGeo, starMat);
            galaxyStars.userData.velocities = starVelocities;  // L∆∞u v·∫≠n t·ªëc
            galaxyStars.userData.initialPositions = new Float32Array(starPositions);  // L∆∞u v·ªã tr√≠ ban ƒë·∫ßu
            scene.add(galaxyStars);
        }

        function createParticleSystem(type, count, size) {
            const pPositions = [];
            const pExplodeTargets = [];
            const pTreeTargets = [];
            const pHeartTargets = [];
            const pPlanetTargets = []; // Th√™m planet targets
            const sizes = [];
            const phases = [];

            for (let i = 0; i < count; i++) {
                // --- TREE Vandiep ---
                const h = Math.random() * CONFIG.treeHeight;
                const y = h - CONFIG.treeHeight / 2;
                let radiusRatio = (type === 'gold') ? Math.sqrt(Math.random()) : 0.9 + Math.random() * 0.1;
                const maxR = (1 - (h / CONFIG.treeHeight)) * CONFIG.treeBaseRadius;
                const r = maxR * radiusRatio;
                const theta = Math.random() * Math.PI * 2;
                pTreeTargets.push(r * Math.cos(theta), y, r * Math.sin(theta));

                // --- EXPLODE Vandiep ---
                const u = Math.random();
                const v = Math.random();
                const phi = Math.acos(2 * v - 1);
                const lam = 2 * Math.PI * u;
                let radMult = (type === 'gift') ? 1.2 : 1.0;
                const rad = CONFIG.explodeRadius * Math.cbrt(Math.random()) * radMult;
                pExplodeTargets.push(rad * Math.sin(phi) * Math.cos(lam), rad * Math.sin(phi) * Math.sin(lam), rad * Math.cos(phi));

                // --- SOFT HEART Vandiep ---
                const tHeart = Math.random() * Math.PI * 2;
                let hx = 16 * Math.pow(Math.sin(tHeart), 3);
                let hy = 13 * Math.cos(tHeart) - 5 * Math.cos(2 * tHeart) - 2 * Math.cos(3 * tHeart) - Math.cos(4 * tHeart);

                const rFill = Math.pow(Math.random(), 0.3); // Soft fill Vandiep
                hx *= rFill; hy *= rFill;
                let hz = (Math.random() - 0.5) * 8 * rFill;

                const noise = 1.0;
                hx += (Math.random() - 0.5) * noise;
                hy += (Math.random() - 0.5) * noise;
                hz += (Math.random() - 0.5) * noise;

                const scaleH = 2.2;
                pHeartTargets.push(hx * scaleH, hy * scaleH + 5, hz);

                // --- PLANET (H√†nh tinh v·ªõi v√≤ng) ---
                const planetChoice = Math.random();

                if (planetChoice < 0.6) {
                    // 60% t·∫°o h√¨nh c·∫ßu (h√†nh tinh)
                    const u2 = Math.random();
                    const v2 = Math.random();
                    const phi2 = Math.acos(2 * v2 - 1);
                    const lam2 = 2 * Math.PI * u2;
                    const planetRadius = 25 * Math.cbrt(Math.random());

                    pPlanetTargets.push(
                        planetRadius * Math.sin(phi2) * Math.cos(lam2),
                        planetRadius * Math.sin(phi2) * Math.sin(lam2),
                        planetRadius * Math.cos(phi2)
                    );
                } else {
                    // 40% t·∫°o v√≤ng xung quanh (rings)
                    const ringAngle = Math.random() * Math.PI * 2;
                    const ringRadius = 30 + Math.random() * 15; // Radius 30-45
                    const ringThickness = (Math.random() - 0.5) * 3; // ƒê·ªô d√†y ¬±3

                    pPlanetTargets.push(
                        ringRadius * Math.cos(ringAngle),
                        ringThickness,
                        ringRadius * Math.sin(ringAngle)
                    );
                }

                // --- INIT Vandiep ---
                pPositions.push(pTreeTargets[i * 3], pTreeTargets[i * 3 + 1], pTreeTargets[i * 3 + 2]);
                sizes.push(size);
                phases.push(Math.random() * Math.PI * 2);
            }

            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pPositions, 3));
            geo.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

            // Init colors Vandiep
            const colors = new Float32Array(count * 3);
            const baseColor = new THREE.Color();
            if (type === 'gold') baseColor.setHex(0xB0E0FF); // Xanh tr·∫Øng s√°ng (bright cyan-white)
            else if (type === 'red') baseColor.setHex(0x87CEFA); // Xanh da tr·ªùi nh·∫°t (light sky blue)
            else baseColor.setHex(0xC0E8FF); // Xanh tr·∫Øng r·∫•t nh·∫°t (pale cyan-white)

            for (let i = 0; i < count; i++) {
                colors[i * 3] = baseColor.r;
                colors[i * 3 + 1] = baseColor.g;
                colors[i * 3 + 2] = baseColor.b;
            }
            geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            geo.userData = {
                tree: pTreeTargets, explode: pExplodeTargets, heart: pHeartTargets, planet: pPlanetTargets,
                phases: phases, baseColor: baseColor, baseSize: size
            };

            const mat = new THREE.PointsMaterial({
                size: size,
                map: textures[type],
                transparent: true, opacity: 1.0,
                vertexColors: true,
                blending: (type === 'gift') ? THREE.NormalBlending : THREE.AdditiveBlending,
                depthWrite: false,
                sizeAttenuation: true
            });

            const points = new THREE.Points(geo, mat);
            scene.add(points);
            return points;
        }

        function createPhotos() {
            // T·∫°o canvas cho texture khung vi·ªÅn ƒë·∫πp
            function createFrameTexture() {
                const canvas = document.createElement('canvas');
                canvas.width = 512;
                canvas.height = 512;
                const ctx = canvas.getContext('2d');

                // N·ªÅn trong su·ªët
                ctx.clearRect(0, 0, 512, 512);

                // V·∫Ω khung vi·ªÅn gradient tr·∫Øng xanh
                const gradient = ctx.createLinearGradient(0, 0, 512, 512);
                gradient.addColorStop(0, '#FFFFFF');   // Tr·∫Øng
                gradient.addColorStop(0.5, '#E0F7FF'); // Tr·∫Øng xanh
                gradient.addColorStop(1, '#B0E0FF');   // Xanh tr·∫Øng

                // Vi·ªÅn ngo√†i
                ctx.strokeStyle = gradient;
                ctx.lineWidth = 30;
                ctx.shadowColor = 'rgba(176, 224, 255, 0.8)'; // Shadow xanh tr·∫Øng
                ctx.shadowBlur = 20;

                // Bo g√≥c
                const radius = 40;
                ctx.beginPath();
                ctx.moveTo(radius, 0);
                ctx.lineTo(512 - radius, 0);
                ctx.arcTo(512, 0, 512, radius, radius);
                ctx.lineTo(512, 512 - radius);
                ctx.arcTo(512, 512, 512 - radius, 512, radius);
                ctx.lineTo(radius, 512);
                ctx.arcTo(0, 512, 0, 512 - radius, radius);
                ctx.lineTo(0, radius);
                ctx.arcTo(0, 0, radius, 0, radius);
                ctx.closePath();
                ctx.stroke();

                // Vi·ªÅn trong (highlight tr·∫Øng)
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.lineWidth = 5;
                ctx.shadowBlur = 10;
                ctx.stroke();

                return new THREE.CanvasTexture(canvas);
            }

            const frameTexture = createFrameTexture();

            for (let i = 0; i < CONFIG.photoCount; i++) {
                const textureIndex = i % photoTextures.length;

                // T√≠nh k√≠ch th∆∞·ªõc plane theo aspect ratio (m·∫∑c ƒë·ªãnh 1:1 n·∫øu ch∆∞a load)
                const aspectRatio = photoAspectRatios[textureIndex] || 1;
                const baseHeight = 10;
                const baseWidth = baseHeight * aspectRatio;

                // ·∫¢nh ch√≠nh - PlaneGeometry theo t·ª∑ l·ªá ·∫£nh
                const photoGeo = new THREE.PlaneGeometry(baseWidth, baseHeight);

                const mat = new THREE.MeshBasicMaterial({
                    map: photoTextures[textureIndex],
                    side: THREE.DoubleSide
                });

                const mesh = new THREE.Mesh(photoGeo, mat);

                // Khung vi·ªÅn - c≈©ng theo t·ª∑ l·ªá ·∫£nh (th√™m padding)
                const framePadding = 1.2; // 20% padding
                const frameWidth = baseWidth * framePadding;
                const frameHeight = baseHeight * framePadding;
                const framePlane = new THREE.PlaneGeometry(frameWidth, frameHeight);
                const frameMat = new THREE.MeshBasicMaterial({
                    map: frameTexture,
                    transparent: true,
                    opacity: 0.9,
                    side: THREE.DoubleSide
                });

                const frame = new THREE.Mesh(framePlane, frameMat);
                frame.position.z = -0.05;
                mesh.add(frame);

                mesh.visible = false;
                mesh.scale.set(0, 0, 0);

                mesh.userData.frameMat = frameMat;
                mesh.userData.orbitPhase = Math.random() * Math.PI * 2;
                mesh.userData.orbitSpeed = 0.3 + Math.random() * 0.4;
                mesh.userData.orbitRadius = 30 + Math.random() * 20;
                mesh.userData.heightOffset = (Math.random() - 0.5) * 15;
                mesh.userData.floatSpeed = 0.5 + Math.random() * 0.5;
                mesh.userData.rotationSpeed = (Math.random() - 0.5) * 0.2;

                scene.add(mesh);
                photoMeshes.push(mesh);
            }
        }

        function createDecorations() {
            // MERRY CHRISTMAS Vandiep
            const canvas = document.createElement('canvas');
            canvas.width = 1024; canvas.height = 256;
            const ctx = canvas.getContext('2d');
            ctx.font = 'bold italic 90px "Times New Roman"';
            ctx.fillStyle = '#FFD700'; ctx.textAlign = 'center';
            ctx.shadowColor = "#FF0000"; ctx.shadowBlur = 40;
            ctx.fillText("", 512, 130);
            const tex = new THREE.CanvasTexture(canvas);
            const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true, blending: THREE.AdditiveBlending });
            titleMesh = new THREE.Mesh(new THREE.PlaneGeometry(60, 15), mat);
            titleMesh.position.set(0, 50, 0);
            scene.add(titleMesh);

            // STAR Vandiep - White Cyan Theme
            const starCanvas = document.createElement('canvas');
            starCanvas.width = 128; starCanvas.height = 128;
            const sCtx = starCanvas.getContext('2d');
            const cx = 64, cy = 64, outer = 50, inner = 20;

            // V·∫Ω √°nh s√°ng ph√°t ra (glow)
            const glowGrad = sCtx.createRadialGradient(cx, cy, 0, cx, cy, 60);
            glowGrad.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
            glowGrad.addColorStop(0.5, 'rgba(176, 224, 255, 0.4)');
            glowGrad.addColorStop(1, 'rgba(176, 224, 255, 0)');
            sCtx.fillStyle = glowGrad;
            sCtx.beginPath();
            sCtx.arc(cx, cy, 60, 0, Math.PI * 2);
            sCtx.fill();

            // V·∫Ω ng√¥i sao v·ªõi gradient
            sCtx.beginPath();
            for (let i = 0; i < 5; i++) {
                sCtx.lineTo(cx + Math.cos((18 + i * 72) / 180 * Math.PI) * outer, cy - Math.sin((18 + i * 72) / 180 * Math.PI) * outer);
                sCtx.lineTo(cx + Math.cos((54 + i * 72) / 180 * Math.PI) * inner, cy - Math.sin((54 + i * 72) / 180 * Math.PI) * inner);
            }
            sCtx.closePath();

            // Gradient tr·∫Øng xanh cho ng√¥i sao
            const starGrad = sCtx.createRadialGradient(cx - 10, cy - 10, 0, cx, cy, outer);
            starGrad.addColorStop(0, '#FFFFFF');   // Tr·∫Øng s√°ng
            starGrad.addColorStop(0.5, '#E0F7FF'); // Tr·∫Øng xanh
            starGrad.addColorStop(1, '#B0E0FF');   // Xanh tr·∫Øng
            sCtx.fillStyle = starGrad;
            sCtx.fill();

            // Vi·ªÅn ngo√†i ƒë·∫πp (double stroke)
            sCtx.strokeStyle = '#FFFFFF';
            sCtx.lineWidth = 3;
            sCtx.shadowColor = 'rgba(176, 224, 255, 0.8)';
            sCtx.shadowBlur = 15;
            sCtx.stroke();

            // Vi·ªÅn trong (highlight)
            sCtx.strokeStyle = '#FFFFFF';
            sCtx.lineWidth = 1.5;
            sCtx.shadowBlur = 8;
            sCtx.stroke();
            const starTex = new THREE.CanvasTexture(starCanvas);
            const starMat = new THREE.MeshBasicMaterial({ map: starTex, transparent: true, blending: THREE.AdditiveBlending });
            starMesh = new THREE.Mesh(new THREE.PlaneGeometry(12, 12), starMat);
            starMesh.position.set(0, CONFIG.treeHeight / 2 + 2, 0);
            scene.add(starMesh);

            // I LOVE YOU TEXT Vandiep
            const loveCanvas = document.createElement('canvas');
            loveCanvas.width = 1024; loveCanvas.height = 256;
            const lCtx = loveCanvas.getContext('2d');
            lCtx.font = 'bold 120px "Segoe UI", sans-serif';
            lCtx.fillStyle = '#FF69B4'; lCtx.textAlign = 'center';
            lCtx.shadowColor = "#FF1493"; lCtx.shadowBlur = 40;
            lCtx.fillText("I LOVE YOU ‚ù§Ô∏è", 512, 130);
            const loveTex = new THREE.CanvasTexture(loveCanvas);
            const loveMat = new THREE.MeshBasicMaterial({ map: loveTex, transparent: true, blending: THREE.AdditiveBlending });
            loveMesh = new THREE.Mesh(new THREE.PlaneGeometry(70, 18), loveMat);
            loveMesh.position.set(0, 0, 20);
            loveMesh.visible = false;
            scene.add(loveMesh);
        }

        function updateParticleGroup(group, type, targetState, speed, handRotY, time) {
            const positions = group.geometry.attributes.position.array;
            const sizes = group.geometry.attributes.size.array;
            const colors = group.geometry.attributes.color.array;
            const phases = group.geometry.userData.phases;
            const baseColor = group.geometry.userData.baseColor;
            const baseSize = group.geometry.userData.baseSize;

            const targetKey = (targetState === 'TREE') ? 'tree' : (targetState === 'HEART' ? 'heart' : 'explode');
            const targets = group.geometry.userData[(targetState === 'PHOTO') ? 'explode' : targetKey];

            // 1. Vandiep
            for (let i = 0; i < positions.length; i++) {
                positions[i] += (targets[i] - positions[i]) * speed;
            }
            group.geometry.attributes.position.needsUpdate = true;

            // 2. COLOR & SIZE Vandiep
            const count = positions.length / 3;

            if (targetState === 'TREE') {
                group.rotation.y += 0.003;

                // Initialize flash data if not exists
                if (!group.userData.flashData) {
                    group.userData.flashData = [];
                    for (let i = 0; i < count; i++) {
                        group.userData.flashData.push({
                            nextFlashTime: time + Math.random() * 5, // Random delay 0-5s
                            isFlashing: false,
                            flashStartTime: 0,
                            flashDuration: 0.3 + Math.random() * 0.2 // 0.3-0.5s
                        });
                    }
                }

                for (let i = 0; i < count; i++) {
                    const flashData = group.userData.flashData[i];
                    let brightness = 1.0;
                    let sizeMultiplier = 1.0;

                    // Check if should start flashing (only for gold and gift)
                    if ((type === 'gold' || type === 'gift') && !flashData.isFlashing && time >= flashData.nextFlashTime) {
                        flashData.isFlashing = true;
                        flashData.flashStartTime = time;
                    }

                    // Handle flash effect
                    if (flashData.isFlashing) {
                        const flashProgress = (time - flashData.flashStartTime) / flashData.flashDuration;

                        if (flashProgress >= 1.0) {
                            // Flash ended
                            flashData.isFlashing = false;
                            flashData.nextFlashTime = time + 2 + Math.random() * 5; // Next flash in 2-7s
                        } else {
                            // Flash in progress - create bright cyan-white glow
                            const flashIntensity = Math.sin(flashProgress * Math.PI); // 0 -> 1 -> 0

                            // Bright cyan-white flash (STRONGER)
                            const cyanFlash = flashIntensity * 5.0; // Much brighter!
                            colors[i * 3] = Math.min(1.0, baseColor.r + cyanFlash * 0.7); // R (less red)
                            colors[i * 3 + 1] = Math.min(1.0, baseColor.g + cyanFlash * 0.9); // G (more green)
                            colors[i * 3 + 2] = Math.min(1.0, baseColor.b + cyanFlash); // B (full blue for cyan)

                            // Size increase during flash (BIGGER)
                            sizeMultiplier = 1.0 + flashIntensity * 1.5;
                            sizes[i] = baseSize * sizeMultiplier;
                            continue; // Skip normal brightness calculation
                        }
                    }

                    // Normal brightness (when not flashing)
                    if (type === 'red') {
                        // RED - slow pulse
                        brightness = 0.5 + 0.5 * Math.sin(time * 3 + phases[i]);
                    } else if (type === 'gold') {
                        // YELLOW - fast twinkle
                        brightness = 0.8 + 0.4 * Math.sin(time * 10 + phases[i]);
                    } else if (type === 'gift') {
                        // GIFT - medium pulse
                        brightness = 0.7 + 0.3 * Math.sin(time * 5 + phases[i]);
                    }

                    colors[i * 3] = baseColor.r * brightness;
                    colors[i * 3 + 1] = baseColor.g * brightness;
                    colors[i * 3 + 2] = baseColor.b * brightness;
                    sizes[i] = baseSize * sizeMultiplier;
                }
                group.geometry.attributes.color.needsUpdate = true;
                group.geometry.attributes.size.needsUpdate = true;

            } else if (targetState === 'HEART') {
                // Hi·ªáu ·ª©ng ƒë·∫≠p tim m∆∞·ª£t m√† h∆°n
                const heartBeat = Math.sin(time * 2.5); // Nh·ªãp ƒë·∫≠p ch·∫≠m h∆°n
                const beatScale = 1 + heartBeat * heartBeat * 0.2; // ƒê·∫≠p m·∫°nh h∆°n

                // Xoay nh·∫π theo nh·ªãp ƒë·∫≠p
                group.rotation.y = Math.sin(time * 1.5) * 0.1;
                group.rotation.z = Math.cos(time * 1.5) * 0.05;

                // Scale theo nh·ªãp ƒë·∫≠p
                group.scale.set(beatScale, beatScale, beatScale);

                // Particles di chuy·ªÉn theo nh·ªãp ƒë·∫≠p (hi·ªáu ·ª©ng xung)
                const pulseEffect = Math.sin(time * 2.5) * 0.5;
                for (let i = 0; i < count; i++) {
                    const idx = i * 3;
                    // Th√™m chuy·ªÉn ƒë·ªông xung t·ª´ t√¢m ra ngo√†i
                    const dx = targets[idx] - 0;
                    const dy = targets[idx + 1] - 5;
                    const dz = targets[idx + 2] - 0;
                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);

                    if (dist > 0.1) {
                        const pulse = pulseEffect * 0.3;
                        positions[idx] = targets[idx] + (dx / dist) * pulse;
                        positions[idx + 1] = targets[idx + 1] + (dy / dist) * pulse;
                        positions[idx + 2] = targets[idx + 2] + (dz / dist) * pulse;
                    }

                    // M√†u s·∫Øc gradient theo nh·ªãp ƒë·∫≠p
                    const intensity = 0.7 + heartBeat * 0.3;

                    // Hi·ªÉn th·ªã particles theo pattern ƒë·∫πp h∆°n
                    if (i % 2 === 0) {
                        sizes[i] = baseSize * (1 + heartBeat * 0.3);
                        colors[i * 3] = baseColor.r * intensity;
                        colors[i * 3 + 1] = baseColor.g * intensity * 0.5;
                        colors[i * 3 + 2] = baseColor.b * intensity * 0.5;
                    } else {
                        sizes[i] = baseSize * 0.5;
                        colors[i * 3] = baseColor.r * 0.3;
                        colors[i * 3 + 1] = baseColor.g * 0.3;
                        colors[i * 3 + 2] = baseColor.b * 0.3;
                    }
                }

                group.geometry.attributes.position.needsUpdate = true;
                group.geometry.attributes.color.needsUpdate = true;
                group.geometry.attributes.size.needsUpdate = true;

            } else if (targetState === 'PLANET') {
                // Hi·ªáu ·ª©ng h√†nh tinh v·ªõi v√≤ng xung quanh
                group.rotation.y += 0.01; // Xoay ch·∫≠m
                group.rotation.x = Math.sin(time * 0.5) * 0.2; // Nghi√™ng nh·∫π
                group.scale.set(1, 1, 1);

                for (let i = 0; i < count; i++) {
                    // M√†u s·∫Øc gradient cho h√†nh tinh
                    const intensity = 0.8 + Math.sin(time * 2 + phases[i]) * 0.2;

                    if (type === 'gold') {
                        // V√†ng cho h√†nh tinh
                        colors[i * 3] = baseColor.r * intensity;
                        colors[i * 3 + 1] = baseColor.g * intensity;
                        colors[i * 3 + 2] = baseColor.b * intensity * 0.7;
                        sizes[i] = baseSize * (0.8 + intensity * 0.2);
                    } else if (type === 'red') {
                        // ƒê·ªè/cam cho v√≤ng
                        colors[i * 3] = baseColor.r * intensity;
                        colors[i * 3 + 1] = baseColor.g * intensity * 0.5;
                        colors[i * 3 + 2] = baseColor.b * intensity * 0.3;
                        sizes[i] = baseSize * 0.6;
                    } else {
                        // Tr·∫Øng cho highlights
                        colors[i * 3] = 1;
                        colors[i * 3 + 1] = 1;
                        colors[i * 3 + 2] = 1;
                        sizes[i] = baseSize * 0.8;
                    }
                }

                group.geometry.attributes.color.needsUpdate = true;
                group.geometry.attributes.size.needsUpdate = true;

            } else {
                // EXPLODE - Hi·ªáu ·ª©ng ng√¢n h√† tr√¥i n·ªïi, xoay v√† di chuy·ªÉn theo tay (2D control)
                group.scale.set(1, 1, 1);

                // Di chuy·ªÉn theo v·ªã tr√≠ tay
                const targetPosX = (handX - 0.5) * 80; // Di chuy·ªÉn ngang ¬±40
                const targetPosY = -(handY - 0.5) * 60; // Di chuy·ªÉn d·ªçc ¬±30 (ƒë·∫£o ng∆∞·ª£c v√¨ Y camera)

                // L√†m m∆∞·ª£t chuy·ªÉn ƒë·ªông di chuy·ªÉn
                // group.position.x += (targetPosX - group.position.x) * 0.08;
                // group.position.y += (targetPosY - group.position.y) * 0.08;

                // Xoay theo v·ªã tr√≠ tay 2D (handX: tr√°i/ph·∫£i, handY: l√™n/xu·ªëng)
                // handX = 0.5 l√† gi·ªØa, < 0.5 l√† tr√°i, > 0.5 l√† ph·∫£i
                // handY = 0.5 l√† gi·ªØa, < 0.5 l√† tr√™n, > 0.5 l√† d∆∞·ªõi

                const targetRotY = (handX - 0.5) * Math.PI * 2; // Xoay tr√°i/ph·∫£i (Y axis)
                const targetRotX = (handY - 0.5) * Math.PI * 2; // Xoay l√™n/xu·ªëng (X axis)

                // L√†m m∆∞·ª£t chuy·ªÉn ƒë·ªông xoay
                group.rotation.y += (targetRotY - group.rotation.y) * 0.05;
                group.rotation.x += (targetRotX - group.rotation.x) * 0.05;

                // Th√™m xoay nh·∫π theo tr·ª•c Z ƒë·ªÉ t·∫°o hi·ªáu ·ª©ng 3D t·ª± nhi√™n h∆°n
                const targetRotZ = Math.sin(time * 0.2) * 0.05; // Dao ƒë·ªông nh·∫π theo Z
                group.rotation.z += (targetRotZ - group.rotation.z) * 0.05;

                // T·∫°o hi·ªáu ·ª©ng s√≥ng v√† tr√¥i n·ªïi cho t·ª´ng h·∫°t
                for (let i = 0; i < count; i++) {
                    const idx = i * 3;

                    // Th√™m chuy·ªÉn ƒë·ªông s√≥ng nh·∫π nh√†ng
                    const waveX = Math.sin(time * 0.5 + phases[i]) * 0.3;
                    const waveY = Math.cos(time * 0.4 + phases[i] * 2) * 0.3;
                    const waveZ = Math.sin(time * 0.6 + phases[i] * 1.5) * 0.3;

                    positions[idx] += waveX * 0.02;
                    positions[idx + 1] += waveY * 0.02;
                    positions[idx + 2] += waveZ * 0.02;

                    // K√©o v·ªÅ v·ªã tr√≠ target ƒë·ªÉ kh√¥ng tr√¥i qu√° xa
                    positions[idx] += (targets[idx] - positions[idx]) * 0.01;
                    positions[idx + 1] += (targets[idx + 1] - positions[idx + 1]) * 0.01;
                    positions[idx + 2] += (targets[idx + 2] - positions[idx + 2]) * 0.01;

                    // Hi·ªáu ·ª©ng l·∫•p l√°nh nh∆∞ ng√¢n h√†
                    let brightness = 0.6 + 0.4 * Math.sin(time * 3 + phases[i] * 10);

                    // M·ªôt s·ªë h·∫°t s√°ng h∆°n t·∫°o ƒëi·ªÉm nh·∫•n
                    if (i % 7 === 0) {
                        brightness = 0.9 + 0.1 * Math.sin(time * 8 + phases[i]);
                        sizes[i] = baseSize * (1.2 + 0.3 * Math.sin(time * 5 + phases[i]));
                    } else {
                        sizes[i] = baseSize * (0.8 + 0.2 * Math.sin(time * 4 + phases[i]));
                    }

                    colors[i * 3] = baseColor.r * brightness;
                    colors[i * 3 + 1] = baseColor.g * brightness;
                    colors[i * 3 + 2] = baseColor.b * brightness;
                }

                group.geometry.attributes.position.needsUpdate = true;
                group.geometry.attributes.size.needsUpdate = true;
                group.geometry.attributes.color.needsUpdate = true;
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.001;
            const speed = 0.12; // TƒÉng t·ªëc ƒë·ªô chuy·ªÉn ƒë·ªïi ƒë·ªÉ m∆∞·ª£t h∆°n
            const handRotY = (handX - 0.5) * 4.0;

            updateParticleGroup(groupGold, 'gold', state, speed, handRotY, time);
            updateParticleGroup(groupRed, 'red', state, speed, handRotY, time);
            updateParticleGroup(groupGift, 'gift', state, speed, handRotY, time);

            // C·∫≠p nh·∫≠t tuy·∫øt r∆°i
            if (snowParticles) {
                const snowPos = snowParticles.geometry.attributes.position.array;
                const velocities = snowParticles.geometry.userData.velocities;

                for (let i = 0; i < velocities.length; i++) {
                    // R∆°i xu·ªëng
                    snowPos[i * 3 + 1] += velocities[i].y;
                    // Tr√¥i ngang
                    snowPos[i * 3] += velocities[i].drift * Math.sin(time + i);

                    // Reset khi r∆°i xu·ªëng d∆∞·ªõi
                    if (snowPos[i * 3 + 1] < -75) {
                        snowPos[i * 3 + 1] = 75;
                        snowPos[i * 3] = (Math.random() - 0.5) * 200;
                        snowPos[i * 3 + 2] = (Math.random() - 0.5) * 200;
                    }
                }
                snowParticles.geometry.attributes.position.needsUpdate = true;
            }

            // C·∫≠p nh·∫≠t sao thi√™n h√† (r∆°i xu·ªëng nh∆∞ tuy·∫øt)
            if (galaxyStars) {
                const starPos = galaxyStars.geometry.attributes.position.array;
                const velocities = galaxyStars.userData.velocities;
                const initialPos = galaxyStars.userData.initialPositions;

                // C·∫≠p nh·∫≠t v·ªã tr√≠ sao (r∆°i xu·ªëng)
                for (let i = 0; i < velocities.length; i++) {
                    const idx = i * 3;

                    // R∆°i xu·ªëng
                    starPos[idx + 1] += velocities[i].y;

                    // Tr√¥i ngang nh·∫π
                    starPos[idx] += velocities[i].drift * Math.sin(time * 0.5 + i);

                    // Reset khi r∆°i qu√° th·∫•p (d∆∞·ªõi -200)
                    if (starPos[idx + 1] < -200) {
                        // ƒê·∫∑t l·∫°i v·ªã tr√≠ ban ƒë·∫ßu
                        starPos[idx] = initialPos[idx];
                        starPos[idx + 1] = initialPos[idx + 1];
                        starPos[idx + 2] = initialPos[idx + 2];
                    }
                }
                galaxyStars.geometry.attributes.position.needsUpdate = true;

                // Xoay nh·∫π
                galaxyStars.rotation.y += 0.0001;
                galaxyStars.rotation.x += 0.00005;

                // Hi·ªáu ·ª©ng l·∫•p l√°nh
                const starSizes = galaxyStars.geometry.attributes.size.array;
                for (let i = 0; i < starSizes.length; i++) {
                    const baseSize = 0.5 + Math.random() * 1.5;
                    starSizes[i] = baseSize + Math.sin(time * 2 + i * 0.1) * 0.3;
                }
                galaxyStars.geometry.attributes.size.needsUpdate = true;
            }

            photoMeshes.forEach((mesh, i) => {
                if (!mesh.material.map && photoTextures[i]) {
                    mesh.material.map = photoTextures[i]; mesh.material.needsUpdate = true;
                }
            });

            if (state === 'TREE') {
                titleMesh.visible = true; starMesh.visible = true; loveMesh.visible = false;
                titleMesh.scale.lerp(new THREE.Vector3(1, 1, 1), 0.1);
                starMesh.rotation.z -= 0.02;
                starMesh.material.opacity = 0.7 + 0.3 * Math.sin(time * 5);
                photoMeshes.forEach(m => { m.scale.lerp(new THREE.Vector3(0, 0, 0), 0.1); m.visible = false; });

            } else if (state === 'HEART') {
                titleMesh.visible = false; starMesh.visible = false; loveMesh.visible = true;
                photoMeshes.forEach(m => { m.visible = false; });

                // Hi·ªáu ·ª©ng ƒë·∫≠p tim m∆∞·ª£t m√† v·ªõi easing
                const heartBeat = Math.sin(time * 2.5);
                const easeOut = 1 - Math.pow(1 - Math.abs(heartBeat), 2); // Easing function
                const s = 1 + easeOut * 0.15;

                loveMesh.scale.set(s, s, 1);

                // Th√™m hi·ªáu ·ª©ng glow nh·∫•p nh√°y
                loveMesh.material.opacity = 0.9 + heartBeat * 0.1;

                // Xoay nh·∫π theo nh·ªãp ƒë·∫≠p
                loveMesh.rotation.z = Math.sin(time * 1.5) * 0.03;

            } else if (state === 'EXPLODE') {
                titleMesh.visible = false; starMesh.visible = false; loveMesh.visible = false;

                // T√≠nh g√≥c xoay v√≤ng tr√≤n t·ª´ v·ªã tr√≠ tay (2D control)
                const orbitRotation = (handX - 0.5) * 0.05; // Tay tr√°i/ph·∫£i t·∫°o xoay v√≤ng ngang
                const verticalTilt = (handY - 0.5) * Math.PI * 0.8; // Tay l√™n/xu·ªëng nghi√™ng v√≤ng tr√≤n

                // H∆∞·ªõng xoay ·∫£nh theo tay
                const imageRotation = (handX - 0.5) * 0.02;

                let bestIdx = 0; let maxZ = -999;
                photoMeshes.forEach((mesh, i) => {
                    mesh.visible = true;

                    // G√≥c c∆° b·∫£n c·ªßa m·ªói ·∫£nh
                    const baseAngle = (i / CONFIG.photoCount) * Math.PI * 2;

                    // Th√™m g√≥c xoay v√≤ng theo tay (t√≠ch l≈©y)
                    if (!mesh.userData.currentOrbitAngle) {
                        mesh.userData.currentOrbitAngle = baseAngle;
                    }
                    mesh.userData.currentOrbitAngle += orbitRotation;

                    const radius = mesh.userData.orbitRadius;

                    // V·ªã tr√≠ tr√™n v√≤ng tr√≤n 3D v·ªõi g√≥c nghi√™ng theo handY
                    const horizontalX = Math.cos(mesh.userData.currentOrbitAngle) * radius;
                    const horizontalZ = Math.sin(mesh.userData.currentOrbitAngle) * radius;

                    // √Åp d·ª•ng nghi√™ng theo tr·ª•c X (tay l√™n/xu·ªëng) - kh√¥ng di chuy·ªÉn, ch·ªâ xoay
                    const x = horizontalX;
                    const y = mesh.userData.heightOffset + horizontalZ * Math.sin(verticalTilt);
                    const z = horizontalZ * Math.cos(verticalTilt);

                    mesh.position.lerp(new THREE.Vector3(x, y, z), 0.08);

                    // Xoay 3D 360 ƒë·ªô v√¥ ƒë·ªãnh thay v√¨ lookAt camera
                    // M·ªói ·∫£nh c√≥ t·ªëc ƒë·ªô xoay ri√™ng
                    if (!mesh.userData.rotationX) mesh.userData.rotationX = Math.random() * 0.02 - 0.01;
                    if (!mesh.userData.rotationY) mesh.userData.rotationY = Math.random() * 0.02 - 0.01;
                    if (!mesh.userData.rotationZ) mesh.userData.rotationZ = Math.random() * 0.02 - 0.01;

                    mesh.rotation.x += mesh.userData.rotationX;
                    mesh.rotation.y += mesh.userData.rotationY;
                    mesh.rotation.z += mesh.userData.rotationZ + imageRotation;

                    if (z > maxZ) { maxZ = z; bestIdx = i; }

                    // K√≠ch th∆∞·ªõc d·ª±a tr√™n kho·∫£ng c√°ch
                    const distanceFromCamera = mesh.position.distanceTo(camera.position);
                    const scaleFactor = Math.max(0.4, Math.min(1.0, 120 / distanceFromCamera));
                    mesh.scale.lerp(new THREE.Vector3(scaleFactor, scaleFactor, scaleFactor), 0.08);

                    // ƒê·ªô s√°ng khung d·ª±a tr√™n kho·∫£ng c√°ch
                    const opacityBase = Math.max(0.4, Math.min(0.9, 100 / distanceFromCamera));
                    const glowIntensity = 0.8 + 0.2 * Math.sin(time * 2 + i);
                    mesh.userData.frameMat.opacity = opacityBase * glowIntensity;
                });
                selectedIndex = bestIdx;

            } else if (state === 'PHOTO') {
                loveMesh.visible = false;
                photoMeshes.forEach((mesh, i) => {
                    if (i === selectedIndex) {
                        mesh.position.lerp(new THREE.Vector3(0, 0, 60), 0.15); // TƒÉng lerp factor cho m∆∞·ª£t h∆°n
                        // Zoom v·ª´a ph·∫£i v·ªõi animation m∆∞·ª£t m√†
                        const zoomScale = 3.5 + Math.sin(time * 2) * 0.15;
                        mesh.scale.lerp(new THREE.Vector3(zoomScale, zoomScale, zoomScale), 0.15); // TƒÉng lerp factor
                        mesh.lookAt(camera.position);
                        mesh.rotation.z = 0;
                        // Khung v√†ng ph√°t s√°ng m·∫°nh
                        mesh.userData.frameMat.opacity = 0.9 + 0.1 * Math.sin(time * 4);
                    } else {
                        mesh.scale.lerp(new THREE.Vector3(0, 0, 0), 0.18); // TƒÉng t·ªëc ƒë·ªô ·∫©n
                        mesh.userData.frameMat.opacity = 0;
                    }
                });
            } else if (state === 'PLANET') {
                // Hi·ªÉn th·ªã letter box khi ch·ªâ tay
                titleMesh.visible = false;
                starMesh.visible = false;
                loveMesh.visible = false;
                photoMeshes.forEach(m => { m.visible = false; });

                const letterBox = document.getElementById('letter-box');
                if (!letterBox.classList.contains('visible')) {
                    // Reset animation b·∫±ng c√°ch x√≥a v√† th√™m l·∫°i c√°c paragraphs
                    const letterContent = letterBox.querySelector('.letter-content');
                    const paragraphs = letterContent.querySelectorAll('p');
                    const signature = letterContent.querySelector('.letter-signature');
                    const hint = letterContent.querySelector('.letter-close-hint');

                    // Clone v√† replace ƒë·ªÉ reset animation
                    paragraphs.forEach(p => {
                        const clone = p.cloneNode(true);
                        p.parentNode.replaceChild(clone, p);
                    });

                    if (signature) {
                        const sigClone = signature.cloneNode(true);
                        signature.parentNode.replaceChild(sigClone, signature);
                    }

                    if (hint) {
                        const hintClone = hint.cloneNode(true);
                        hint.parentNode.replaceChild(hintClone, hint);
                    }

                    letterBox.classList.add('visible');
                }
            }

            // ·∫®n letter box khi kh√¥ng ph·∫£i state PLANET
            if (state !== 'PLANET') {
                const letterBox = document.getElementById('letter-box');
                if (letterBox.classList.contains('visible')) {
                    letterBox.classList.remove('visible');
                }
            }

            renderer.render(scene, camera);
        }

        // Book page navigation
        let currentPage = 1;
        const totalPages = 3;

        function nextPage() {
            if (currentPage >= totalPages) return;

            const currentPageEl = document.querySelector(`.page[data-page="${currentPage + 1}"]`);
            if (currentPageEl) {
                currentPageEl.style.display = 'block';
                setTimeout(() => {
                    currentPageEl.classList.add('flipped');
                }, 50);
            }

            currentPage++;
            updatePageButtons();
        }

        function previousPage() {
            if (currentPage <= 1) return;

            const currentPageEl = document.querySelector(`.page[data-page="${currentPage}"]`);
            if (currentPageEl) {
                currentPageEl.classList.remove('flipped');
                setTimeout(() => {
                    currentPageEl.style.display = 'none';
                }, 800);
            }

            currentPage--;
            updatePageButtons();
        }

        function updatePageButtons() {
            document.getElementById('prevPage').disabled = currentPage <= 1;
            document.getElementById('nextPage').disabled = currentPage >= totalPages;
        }

        function startExperience() {
            // ·∫®n welcome screen
            document.getElementById('welcome-screen').classList.add('hidden');
            // B·∫Øt ƒë·∫ßu h·ªá th·ªëng
            setTimeout(() => {
                startSystem();
            }, 800);
        }

        function startSystem() {
            document.getElementById('btnStart').style.display = 'none';
            bgMusic.play().catch(e => console.log(e));
            init3D();

            const video = document.getElementsByClassName('input_video')[0];
            const canvas = document.getElementById('camera-preview');
            const ctx = canvas.getContext('2d');

            const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
            // TƒÉng confidence ƒë·ªÉ nh·∫≠n di·ªán ch√≠nh x√°c h∆°n
            hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7 });

            // Gesture smoothing buffer
            let gestureBuffer = [];
            const BUFFER_SIZE = 5; // S·ªë frame ƒë·ªÉ x√°c nh·∫≠n gesture
            let gestureConfirmCounter = 0;
            const CONFIRM_THRESHOLD = 3; // C·∫ßn 3/5 frame gi·ªëng nhau ƒë·ªÉ x√°c nh·∫≠n

            hands.onResults(results => {
                ctx.clearRect(0, 0, 100, 75); ctx.drawImage(results.image, 0, 0, 100, 75);

                let detectedGesture = state; // M·∫∑c ƒë·ªãnh gi·ªØ nguy√™n state hi·ªán t·∫°i

                // --- Hand Logic: Gi·ªØ tr·∫°ng th√°i khi tay ra kh·ªèi khung h√¨nh ---
                if (results.multiHandLandmarks.length === 2) {
                    const h1 = results.multiHandLandmarks[0]; const h2 = results.multiHandLandmarks[1];
                    const distIndex = Math.hypot(h1[8].x - h2[8].x, h1[8].y - h2[8].y);
                    const distThumb = Math.hypot(h1[4].x - h2[4].x, h1[4].y - h2[4].y);
                    if (distIndex < 0.12 && distThumb < 0.12) { // Ng∆∞·ª°ng ch·∫∑t h∆°n
                        detectedGesture = 'HEART';
                    }
                }

                if (results.multiHandLandmarks.length > 0) {
                    const lm = results.multiHandLandmarks[0];
                    // Smooth hand position v·ªõi lerp
                    const newHandX = lm[9].x;
                    const newHandY = lm[9].y;
                    handX += (newHandX - handX) * 0.3; // L√†m m∆∞·ª£t v·ªã tr√≠ tay
                    handY += (newHandY - handY) * 0.3;

                    const tips = [8, 12, 16, 20];
                    const wrist = lm[0];

                    // T√≠nh kho·∫£ng c√°ch t·ª´ c√°c ƒë·∫ßu ng√≥n tay ƒë·∫øn c·ªï tay
                    let openDist = 0;
                    tips.forEach(i => openDist += Math.hypot(lm[i].x - wrist.x, lm[i].y - wrist.y));
                    const avgDist = openDist / 4;
                    const pinchDist = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);

                    // Ki·ªÉm tra ch·ªâ 1 ng√≥n (index finger pointing)
                    const indexUp = Math.hypot(lm[8].x - wrist.x, lm[8].y - wrist.y);
                    const middleUp = Math.hypot(lm[12].x - wrist.x, lm[12].y - wrist.y);
                    const ringUp = Math.hypot(lm[16].x - wrist.x, lm[16].y - wrist.y);
                    const pinkyUp = Math.hypot(lm[20].x - wrist.x, lm[20].y - wrist.y);

                    // Pointing gesture c·∫£i ti·∫øn v·ªõi ng∆∞·ª°ng ch·∫∑t h∆°n
                    const isPointing = indexUp > 0.30 && // TƒÉng ng∆∞·ª°ng index
                        middleUp < 0.18 &&  // Gi·∫£m ng∆∞·ª°ng middle
                        ringUp < 0.18 &&    // Gi·∫£m ng∆∞·ª°ng ring
                        pinkyUp < 0.18;     // Gi·∫£m ng∆∞·ª°ng pinky

                    // ∆Øu ti√™n cao: N·∫øu ƒëang ·ªü PLANET, ch·ªâ tho√°t khi c√≥ gesture r√µ r√†ng kh√°c
                    if (state === 'PLANET') {
                        // Ch·ªâ tho√°t PLANET khi ph√°t hi·ªán gesture kh√°c R√ï R√ÄNG v·ªõi ng∆∞·ª°ng ch·∫∑t h∆°n
                        if (avgDist < 0.20) {
                            detectedGesture = 'TREE'; // N·∫Øm tay ch·∫∑t h∆°n
                        } else if (pinchDist < 0.035) {
                            detectedGesture = 'PHOTO'; // Pinch ch·∫∑t h∆°n
                        } else if (avgDist > 0.38) {
                            detectedGesture = 'EXPLODE'; // M·ªü tay r·ªông h∆°n
                        } else if (isPointing) {
                            detectedGesture = 'PLANET'; // Gi·ªØ nguy√™n n·∫øu v·∫´n ƒëang ch·ªâ
                        }
                        // N·∫øu kh√¥ng c√≥ gesture r√µ r√†ng, gi·ªØ nguy√™n PLANET
                    } else {
                        // Logic b√¨nh th∆∞·ªùng khi kh√¥ng ·ªü PLANET - ∆∞u ti√™n theo th·ª© t·ª±
                        if (avgDist < 0.23) {
                            detectedGesture = 'TREE';
                        } else if (pinchDist < 0.045) {
                            detectedGesture = 'PHOTO';
                        } else if (isPointing) {
                            detectedGesture = 'PLANET'; // Ch·ªâ 1 ng√≥n ‚Üí PLANET (Letter Box)
                        } else if (avgDist > 0.35) {
                            detectedGesture = 'EXPLODE';
                        }
                        // N·∫øu kh√¥ng match gesture n√†o, gi·ªØ nguy√™n state hi·ªán t·∫°i
                    }
                }

                // Gesture smoothing v·ªõi buffer
                gestureBuffer.push(detectedGesture);
                if (gestureBuffer.length > BUFFER_SIZE) {
                    gestureBuffer.shift();
                }

                // ƒê·∫øm s·ªë l·∫ßn gesture xu·∫•t hi·ªán trong buffer
                const gestureCounts = {};
                gestureBuffer.forEach(g => {
                    gestureCounts[g] = (gestureCounts[g] || 0) + 1;
                });

                // T√¨m gesture xu·∫•t hi·ªán nhi·ªÅu nh·∫•t
                let mostFrequentGesture = state;
                let maxCount = 0;
                for (const [gesture, count] of Object.entries(gestureCounts)) {
                    if (count > maxCount) {
                        maxCount = count;
                        mostFrequentGesture = gesture;
                    }
                }

                // Ch·ªâ thay ƒë·ªïi state n·∫øu gesture xu·∫•t hi·ªán ƒë·ªß s·ªë l·∫ßn (confirmation)
                if (maxCount >= CONFIRM_THRESHOLD && mostFrequentGesture !== state) {
                    state = mostFrequentGesture;
                    gestureBuffer = []; // Reset buffer sau khi chuy·ªÉn state
                }

                // Kh√¥ng l√†m g√¨ khi tay ra kh·ªèi khung h√¨nh - gi·ªØ nguy√™n state hi·ªán t·∫°i
            });

            const cameraUtils = new Camera(video, {
                onFrame: async () => { await hands.send({ image: video }); }, width: 320, height: 240
            });
            cameraUtils.start();
        }

        window.addEventListener('resize', () => {
            if (camera) { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
        });

        // Auto-start when page loads
        window.addEventListener('load', () => {
            // startSystem(); // Removed auto-start to comply with browser autoplay policy
            console.log("Page loaded. Waiting for user interaction to start audio.");
        });
    </script>
</body>

</html>